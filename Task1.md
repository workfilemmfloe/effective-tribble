Task 1
======

We are going to add a capability tp the compiler to create public fields in the generated bytecode.

Background
----------

Whenever you define a property (in a class or package) like this:

    val x = 1

or

    val r x = 1

The compiler creates
  - a private *backing field* named `x`
  - a `getX()` method
  - a `setX(...)` method, for var's only

The backing field is always private, its visibility can not be changed.

But some Java frameworks require public fields, so we'll add
an annotation named `[PublicField]` that tells the compiler to make the field public:

```
  [PublicField]
  val x = 1
```

Reference Materials
-------------------

A similar thing is done in commits

    f757881f [throws] annotation added to the standard library
    4ab0b00b Support [throws] annotation

Use Changes View -> Log (Alt+9 or Cmd+9) to navigate the history.

Adding an annotation is rather straightforward. Don't forget to re-run

    ant dist

after changing the standard library code. Hint: passing `-Dshrink=false -Dgenerate.javadoc=false` will speed this up considerably.

To find the place where the field is created, look for usages of `AbstractClassBuilder.visitField()`, one of its arguments is responsible for
the visibility. The information about an annotation being present is available in a `PropertyDescriptor`.

To look at the generated code use the Kotlin/Bytecode tool window in the debug instance of InetlliJ IDEA
(to run the debug instance: Run -> Run ... -> Choose "IDEA").

To test your results, try to access the field from a Java class.

NOTE: For your changes to be reflected in the compiler (not just the IDE), you have to re-run `ant dist` again.
A faster version of doing this if you only need to update the compiler is

    ant dist_quick_compiler_only

If you want to "hot-swap" the changes, i.e. update the compiler without re-starting the debug IDE instance, you need to do

     Build -> Build artifacts ... -> KotlinPlugin -> Rebuild



Don't forget to add tests
-------------------------