== t1 ==
fun t1() {
  try {
    1
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { 1 } finally { 2 } })
    mark(try { 1 } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])    NEXT:[mark({ 2 }), mark({ 1 })]
  3 mark({ 1 })
    r(1) -> <v0>
  2 jmp(L3 [skipFinallyToErrorBlock])       NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L4 [start finally]:
  3 mark({ 2 })                             PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v1>
L5 [finish finally]:
  2 jmp(error)                              NEXT:[<ERROR>]
L3 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                             PREV:[jmp(L3 [skipFinallyToErrorBlock])]
    r(2) -> <v1>
L1:
  1 <END>                                   NEXT:[<SINK>]
error:
    <ERROR>                                 PREV:[jmp(error)]
sink:
    <SINK>                                  PREV:[<ERROR>, <END>]
=====================
== t2 ==
fun t2() {
  try {
    1
    if (2 > 3) {
      return
    }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { 1 if (2 > 3) { return } } finally { 2 } })
    mark(try { 1 if (2 > 3) { return } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                       NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { return } })]
  3 mark({ 1 if (2 > 3) { return } })
    r(1) -> <v0>
    mark(if (2 > 3) { return })
    r(2) -> <v1>
    r(3) -> <v2>
    mark(2 > 3)
    call(>, compareTo|<v1>, <v2>) -> <v3>
    jf(L3|<v3>)                                                NEXT:[read (Unit), mark({ return })]
  4 mark({ return })
L4 [start finally]:
  5 mark({ 2 })
    r(2) -> <v4>
L5 [finish finally]:
  4 ret L1                                                     NEXT:[<END>]
- 3 jmp(L6)                                                    NEXT:[jmp(L7 [skipFinallyToErrorBlock])]                          PREV:[]
L3:
    read (Unit)                                                PREV:[jf(L3|<v3>)]
L6:
  2 jmp(L7 [skipFinallyToErrorBlock])                          NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
  5 mark({ 2 })                                                PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v4>
  2 jmp(error)                                                 NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
  5 mark({ 2 })                                                PREV:[jmp(L7 [skipFinallyToErrorBlock])]
    r(2) -> <v4>
L1:
  1 <END>                                                      NEXT:[<SINK>]                                                     PREV:[ret L1, r(2) -> <v4>]
error:
    <ERROR>                                                    PREV:[jmp(error)]
sink:
    <SINK>                                                     PREV:[<ERROR>, <END>]
=====================
== t3 ==
fun t3() {
  try {
    1
    @l{ () ->
        if (2 > 3) {
          return@l
        }
    }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { 1 @l{ () -> if (2 > 3) { return@l } } } finally { 2 } })
    mark(try { 1 @l{ () -> if (2 > 3) { return@l } } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                     NEXT:[mark({ 2 }), mark({ 1 @l{ () -> if (2 > 3) { return@l } } })]
  3 mark({ 1 @l{ () -> if (2 > 3) { return@l } } })
    r(1) -> <v0>
    mark(@l{ () -> if (2 > 3) { return@l } })
    mark({ () -> if (2 > 3) { return@l } })
    jmp?(L3)                                                                 NEXT:[r({ () -> if (2 > 3) { return@l } }) -> <v1>, d({ () -> if (2 > 3) { return@l } })]
    d({ () -> if (2 > 3) { return@l } })                                     NEXT:[<SINK>]
L3:
    r({ () -> if (2 > 3) { return@l } }) -> <v1>                             PREV:[jmp?(L3)]
  2 jmp(L8 [skipFinallyToErrorBlock])                                        NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L9 [start finally]:
  3 mark({ 2 })                                                              PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v2>
L10 [finish finally]:
  2 jmp(error)                                                               NEXT:[<ERROR>]
L8 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                              PREV:[jmp(L8 [skipFinallyToErrorBlock])]
    r(2) -> <v2>
L1:
  1 <END>                                                                    NEXT:[<SINK>]
error:
    <ERROR>                                                                  PREV:[jmp(error)]
sink:
    <SINK>                                                                   PREV:[<ERROR>, <END>, d({ () -> if (2 > 3) { return@l } })]
=====================
== anonymous_0 ==
{ () ->
        if (2 > 3) {
          return@l
        }
    }
---------------------
L4:
  4 <START>
  5 mark(if (2 > 3) { return@l })
    mark(if (2 > 3) { return@l })
    r(2) -> <v0>
    r(3) -> <v1>
    mark(2 > 3)
    call(>, compareTo|<v0>, <v1>) -> <v2>
    jf(L6|<v2>)                              NEXT:[read (Unit), mark({ return@l })]
  6 mark({ return@l })
    ret L5                                   NEXT:[<END>]
- 5 jmp(L7)                                  NEXT:[<END>]                                    PREV:[]
L6:
    read (Unit)                              PREV:[jf(L6|<v2>)]
L5:
L7:
  4 <END>                                    NEXT:[<SINK>]                                   PREV:[ret L5, read (Unit)]
error:
    <ERROR>                                  PREV:[]
sink:
    <SINK>                                   PREV:[<ERROR>, <END>]
=====================
== t4 ==
fun t4() {
  @l{ () ->
    try {
      1
      if (2 > 3) {
        return@l
      }
    } finally {
      2
    }
  }
}
---------------------
L0:
  1 <START>
  2 mark({ @l{ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } } })
    mark(@l{ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })
    mark({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })
    jmp?(L2)                                                                 NEXT:[r({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } }) -> <v0>, d({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })]
    d({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })             NEXT:[<SINK>]
L2:
    r({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } }) -> <v0>     PREV:[jmp?(L2)]
L1:
  1 <END>                                                                    NEXT:[<SINK>]
error:
    <ERROR>                                                                  PREV:[]
sink:
    <SINK>                                                                   PREV:[<ERROR>, <END>, d({ () -> try { 1 if (2 > 3) { return@l } } finally { 2 } })]
=====================
== anonymous_1 ==
{ () ->
    try {
      1
      if (2 > 3) {
        return@l
      }
    } finally {
      2
    }
  }
---------------------
L3:
  3 <START>
  4 mark(try { 1 if (2 > 3) { return@l } } finally { 2 })
    mark(try { 1 if (2 > 3) { return@l } } finally { 2 })
    jmp?(L5 [onExceptionToFinallyBlock])                     NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { return@l } })]
  5 mark({ 1 if (2 > 3) { return@l } })
    r(1) -> <v0>
    mark(if (2 > 3) { return@l })
    r(2) -> <v1>
    r(3) -> <v2>
    mark(2 > 3)
    call(>, compareTo|<v1>, <v2>) -> <v3>
    jf(L6|<v3>)                                              NEXT:[read (Unit), mark({ return@l })]
  6 mark({ return@l })
L7 [start finally]:
  7 mark({ 2 })
    r(2) -> <v4>
L8 [finish finally]:
  6 ret L4                                                   NEXT:[<END>]
- 5 jmp(L9)                                                  NEXT:[jmp(L10 [skipFinallyToErrorBlock])]                       PREV:[]
L6:
    read (Unit)                                              PREV:[jf(L6|<v3>)]
L9:
  4 jmp(L10 [skipFinallyToErrorBlock])                       NEXT:[mark({ 2 })]
L5 [onExceptionToFinallyBlock]:
  7 mark({ 2 })                                              PREV:[jmp?(L5 [onExceptionToFinallyBlock])]
    r(2) -> <v4>
  4 jmp(error)                                               NEXT:[<ERROR>]
L10 [skipFinallyToErrorBlock]:
  7 mark({ 2 })                                              PREV:[jmp(L10 [skipFinallyToErrorBlock])]
    r(2) -> <v4>
L4:
  3 <END>                                                    NEXT:[<SINK>]                                                   PREV:[ret L4, r(2) -> <v4>]
error:
    <ERROR>                                                  PREV:[jmp(error)]
sink:
    <SINK>                                                   PREV:[<ERROR>, <END>]
=====================
== t5 ==
fun t5() {
  @l while(true) {
    try {
      1
      if (2 > 3) {
        break @l
      }
    } finally {
      2
    }
  }
}
---------------------
L0:
  1 <START>
  2 mark({ @l while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } } })
    mark(@l while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } })
L2 [loop entry point]:
L5 [condition entry point]:
    r(true) -> <v0>                                                                 PREV:[mark(@l while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } }), jmp(L2 [loop entry point])]
    mark(while(true) { try { 1 if (2 > 3) { break @l } } finally { 2 } })
L4 [body entry point]:
  3 mark({ try { 1 if (2 > 3) { break @l } } finally { 2 } })
    mark(try { 1 if (2 > 3) { break @l } } finally { 2 })
    jmp?(L6 [onExceptionToFinallyBlock])                                            NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { break @l } })]
  4 mark({ 1 if (2 > 3) { break @l } })
    r(1) -> <v1>
    mark(if (2 > 3) { break @l })
    r(2) -> <v2>
    r(3) -> <v3>
    mark(2 > 3)
    call(>, compareTo|<v2>, <v3>) -> <v4>
    jf(L7|<v4>)                                                                     NEXT:[read (Unit), mark({ break @l })]
  5 mark({ break @l })
L8 [start finally]:
  6 mark({ 2 })
    r(2) -> <v5>
L9 [finish finally]:
  5 jmp(L3 [loop exit point])                                                       NEXT:[read (Unit)]
- 4 jmp(L10)                                                                        NEXT:[jmp(L11 [skipFinallyToErrorBlock])]                                              PREV:[]
L7:
    read (Unit)                                                                     PREV:[jf(L7|<v4>)]
L10:
  3 jmp(L11 [skipFinallyToErrorBlock])                                              NEXT:[mark({ 2 })]
L6 [onExceptionToFinallyBlock]:
  6 mark({ 2 })                                                                     PREV:[jmp?(L6 [onExceptionToFinallyBlock])]
    r(2) -> <v5>
  3 jmp(error)                                                                      NEXT:[<ERROR>]
L11 [skipFinallyToErrorBlock]:
  6 mark({ 2 })                                                                     PREV:[jmp(L11 [skipFinallyToErrorBlock])]
    r(2) -> <v5>
  2 jmp(L2 [loop entry point])                                                      NEXT:[r(true) -> <v0>]
L3 [loop exit point]:
    read (Unit)                                                                     PREV:[jmp(L3 [loop exit point])]
L1:
  1 <END>                                                                           NEXT:[<SINK>]
error:
    <ERROR>                                                                         PREV:[jmp(error)]
sink:
    <SINK>                                                                          PREV:[<ERROR>, <END>]
=====================
== t6 ==
fun t6() {
  try {
    @l while(true) {
        1
        if (2 > 3) {
          break @l
        }
      }
      5
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { @l while(true) { 1 if (2 > 3) { break @l } } 5 } finally { 2 } })
    mark(try { @l while(true) { 1 if (2 > 3) { break @l } } 5 } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                              NEXT:[mark({ 2 }), mark({ @l while(true) { 1 if (2 > 3) { break @l } } 5 })]
  3 mark({ @l while(true) { 1 if (2 > 3) { break @l } } 5 })
    mark(@l while(true) { 1 if (2 > 3) { break @l } })
L3 [loop entry point]:
L6 [condition entry point]:
    r(true) -> <v0>                                                                   PREV:[mark(@l while(true) { 1 if (2 > 3) { break @l } }), jmp(L3 [loop entry point])]
    mark(while(true) { 1 if (2 > 3) { break @l } })
L5 [body entry point]:
  4 mark({ 1 if (2 > 3) { break @l } })
    r(1) -> <v1>
    mark(if (2 > 3) { break @l })
    r(2) -> <v2>
    r(3) -> <v3>
    mark(2 > 3)
    call(>, compareTo|<v2>, <v3>) -> <v4>
    jf(L7|<v4>)                                                                       NEXT:[read (Unit), mark({ break @l })]
  5 mark({ break @l })
    jmp(L4 [loop exit point])                                                         NEXT:[read (Unit)]
- 4 jmp(L8)                                                                           NEXT:[jmp(L3 [loop entry point])]                                                        PREV:[]
L7:
    read (Unit)                                                                       PREV:[jf(L7|<v4>)]
L8:
  3 jmp(L3 [loop entry point])                                                        NEXT:[r(true) -> <v0>]
L4 [loop exit point]:
    read (Unit)                                                                       PREV:[jmp(L4 [loop exit point])]
    r(5) -> <v5>
  2 jmp(L9 [skipFinallyToErrorBlock])                                                 NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                       PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v6>
L11 [finish finally]:
  2 jmp(error)                                                                        NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                       PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v6>
L1:
  1 <END>                                                                             NEXT:[<SINK>]
error:
    <ERROR>                                                                           PREV:[jmp(error)]
sink:
    <SINK>                                                                            PREV:[<ERROR>, <END>]
=====================
== t7 ==
fun t7() {
  try {
    @l while(true) {
        1
        if (2 > 3) {
          break @l
        }
      }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { @l while(true) { 1 if (2 > 3) { break @l } } } finally { 2 } })
    mark(try { @l while(true) { 1 if (2 > 3) { break @l } } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                            NEXT:[mark({ 2 }), mark({ @l while(true) { 1 if (2 > 3) { break @l } } })]
  3 mark({ @l while(true) { 1 if (2 > 3) { break @l } } })
    mark(@l while(true) { 1 if (2 > 3) { break @l } })
L3 [loop entry point]:
L6 [condition entry point]:
    r(true) -> <v0>                                                                 PREV:[mark(@l while(true) { 1 if (2 > 3) { break @l } }), jmp(L3 [loop entry point])]
    mark(while(true) { 1 if (2 > 3) { break @l } })
L5 [body entry point]:
  4 mark({ 1 if (2 > 3) { break @l } })
    r(1) -> <v1>
    mark(if (2 > 3) { break @l })
    r(2) -> <v2>
    r(3) -> <v3>
    mark(2 > 3)
    call(>, compareTo|<v2>, <v3>) -> <v4>
    jf(L7|<v4>)                                                                     NEXT:[read (Unit), mark({ break @l })]
  5 mark({ break @l })
    jmp(L4 [loop exit point])                                                       NEXT:[read (Unit)]
- 4 jmp(L8)                                                                         NEXT:[jmp(L3 [loop entry point])]                                                      PREV:[]
L7:
    read (Unit)                                                                     PREV:[jf(L7|<v4>)]
L8:
  3 jmp(L3 [loop entry point])                                                      NEXT:[r(true) -> <v0>]
L4 [loop exit point]:
    read (Unit)                                                                     PREV:[jmp(L4 [loop exit point])]
  2 jmp(L9 [skipFinallyToErrorBlock])                                               NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                     PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v5>
L11 [finish finally]:
  2 jmp(error)                                                                      NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                     PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v5>
L1:
  1 <END>                                                                           NEXT:[<SINK>]
error:
    <ERROR>                                                                         PREV:[jmp(error)]
sink:
    <SINK>                                                                          PREV:[<ERROR>, <END>]
=====================
== t8 ==
fun t8(a : Int) {
  @l for (i in 1..a) {
    try {
      1
      if (2 > 3) {
        continue @l
      }
    } finally {
      2
    }
  }
}
---------------------
L0:
  1 <START>
    v(a : Int)
    magic(a : Int) -> <v0>
    w(a|<v0>)
  2 mark({ @l for (i in 1..a) { try { 1 if (2 > 3) { continue @l } } finally { 2 } } })
    mark(@l for (i in 1..a) { try { 1 if (2 > 3) { continue @l } } finally { 2 } })
  3 r(1) -> <v1>
    r(a) -> <v2>
    mark(1..a)
    call(.., rangeTo|<v1>, <v2>) -> <v3>
    v(i)
L3:
    jmp?(L2)                                                                               NEXT:[read (Unit), magic(1..a|<v3>) -> <v4>]
L4 [loop entry point]:
L5 [body entry point]:
    magic(1..a|<v3>) -> <v4>                                                               PREV:[jmp?(L2), jmp(L4 [loop entry point]), jmp?(L4 [loop entry point])]
    w(i|<v4>)
    mark(for (i in 1..a) { try { 1 if (2 > 3) { continue @l } } finally { 2 } })
  4 mark({ try { 1 if (2 > 3) { continue @l } } finally { 2 } })
    mark(try { 1 if (2 > 3) { continue @l } } finally { 2 })
    jmp?(L6 [onExceptionToFinallyBlock])                                                   NEXT:[mark({ 2 }), mark({ 1 if (2 > 3) { continue @l } })]
  5 mark({ 1 if (2 > 3) { continue @l } })
    r(1) -> <v5>
    mark(if (2 > 3) { continue @l })
    r(2) -> <v6>
    r(3) -> <v7>
    mark(2 > 3)
    call(>, compareTo|<v6>, <v7>) -> <v8>
    jf(L7|<v8>)                                                                            NEXT:[read (Unit), mark({ continue @l })]
  6 mark({ continue @l })
L8 [start finally]:
  7 mark({ 2 })
    r(2) -> <v9>
L9 [finish finally]:
  6 jmp(L4 [loop entry point])                                                             NEXT:[magic(1..a|<v3>) -> <v4>]
- 5 jmp(L10)                                                                               NEXT:[jmp(L11 [skipFinallyToErrorBlock])]                                                     PREV:[]
L7:
    read (Unit)                                                                            PREV:[jf(L7|<v8>)]
L10:
  4 jmp(L11 [skipFinallyToErrorBlock])                                                     NEXT:[mark({ 2 })]
L6 [onExceptionToFinallyBlock]:
  7 mark({ 2 })                                                                            PREV:[jmp?(L6 [onExceptionToFinallyBlock])]
    r(2) -> <v9>
  4 jmp(error)                                                                             NEXT:[<ERROR>]
L11 [skipFinallyToErrorBlock]:
  7 mark({ 2 })                                                                            PREV:[jmp(L11 [skipFinallyToErrorBlock])]
    r(2) -> <v9>
  3 jmp?(L4 [loop entry point])                                                            NEXT:[magic(1..a|<v3>) -> <v4>, read (Unit)]
L2:
    read (Unit)                                                                            PREV:[jmp?(L2), jmp?(L4 [loop entry point])]
L1:
  1 <END>                                                                                  NEXT:[<SINK>]
error:
    <ERROR>                                                                                PREV:[jmp(error)]
sink:
    <SINK>                                                                                 PREV:[<ERROR>, <END>]
=====================
== t9 ==
fun t9(a : Int) {
  try {
    @l for (i in 1..a) {
        1
        if (2 > 3) {
          continue @l
        }
      }
      5
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
    v(a : Int)
    magic(a : Int) -> <v0>
    w(a|<v0>)
  2 mark({ try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 } finally { 2 } })
    mark(try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                                     NEXT:[mark({ 2 }), mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 })]
  3 mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } 5 })
    mark(@l for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  4 r(1) -> <v1>
    r(a) -> <v2>
    mark(1..a)
    call(.., rangeTo|<v1>, <v2>) -> <v3>
    v(i)
L4:
    jmp?(L3)                                                                                 NEXT:[read (Unit), magic(1..a|<v3>) -> <v4>]
L5 [loop entry point]:
L6 [body entry point]:
    magic(1..a|<v3>) -> <v4>                                                                 PREV:[jmp?(L3), jmp(L5 [loop entry point]), jmp?(L5 [loop entry point])]
    w(i|<v4>)
    mark(for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  5 mark({ 1 if (2 > 3) { continue @l } })
    r(1) -> <v5>
    mark(if (2 > 3) { continue @l })
    r(2) -> <v6>
    r(3) -> <v7>
    mark(2 > 3)
    call(>, compareTo|<v6>, <v7>) -> <v8>
    jf(L7|<v8>)                                                                              NEXT:[read (Unit), mark({ continue @l })]
  6 mark({ continue @l })
    jmp(L5 [loop entry point])                                                               NEXT:[magic(1..a|<v3>) -> <v4>]
- 5 jmp(L8)                                                                                  NEXT:[jmp?(L5 [loop entry point])]                                                              PREV:[]
L7:
    read (Unit)                                                                              PREV:[jf(L7|<v8>)]
L8:
  4 jmp?(L5 [loop entry point])                                                              NEXT:[magic(1..a|<v3>) -> <v4>, read (Unit)]
L3:
    read (Unit)                                                                              PREV:[jmp?(L3), jmp?(L5 [loop entry point])]
  3 r(5) -> <v9>
  2 jmp(L9 [skipFinallyToErrorBlock])                                                        NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                              PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v10>
L11 [finish finally]:
  2 jmp(error)                                                                               NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                              PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v10>
L1:
  1 <END>                                                                                    NEXT:[<SINK>]
error:
    <ERROR>                                                                                  PREV:[jmp(error)]
sink:
    <SINK>                                                                                   PREV:[<ERROR>, <END>]
=====================
== t10 ==
fun t10(a : Int) {
  try {
    @l for (i in 1..a) {
        1
        if (2 > 3) {
          continue @l
        }
      }
  } finally {
    2
  }
}
---------------------
L0:
  1 <START>
    v(a : Int)
    magic(a : Int) -> <v0>
    w(a|<v0>)
  2 mark({ try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } } finally { 2 } })
    mark(try { @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } } finally { 2 })
    jmp?(L2 [onExceptionToFinallyBlock])                                                   NEXT:[mark({ 2 }), mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } })]
  3 mark({ @l for (i in 1..a) { 1 if (2 > 3) { continue @l } } })
    mark(@l for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  4 r(1) -> <v1>
    r(a) -> <v2>
    mark(1..a)
    call(.., rangeTo|<v1>, <v2>) -> <v3>
    v(i)
L4:
    jmp?(L3)                                                                               NEXT:[read (Unit), magic(1..a|<v3>) -> <v4>]
L5 [loop entry point]:
L6 [body entry point]:
    magic(1..a|<v3>) -> <v4>                                                               PREV:[jmp?(L3), jmp(L5 [loop entry point]), jmp?(L5 [loop entry point])]
    w(i|<v4>)
    mark(for (i in 1..a) { 1 if (2 > 3) { continue @l } })
  5 mark({ 1 if (2 > 3) { continue @l } })
    r(1) -> <v5>
    mark(if (2 > 3) { continue @l })
    r(2) -> <v6>
    r(3) -> <v7>
    mark(2 > 3)
    call(>, compareTo|<v6>, <v7>) -> <v8>
    jf(L7|<v8>)                                                                            NEXT:[read (Unit), mark({ continue @l })]
  6 mark({ continue @l })
    jmp(L5 [loop entry point])                                                             NEXT:[magic(1..a|<v3>) -> <v4>]
- 5 jmp(L8)                                                                                NEXT:[jmp?(L5 [loop entry point])]                                                            PREV:[]
L7:
    read (Unit)                                                                            PREV:[jf(L7|<v8>)]
L8:
  4 jmp?(L5 [loop entry point])                                                            NEXT:[magic(1..a|<v3>) -> <v4>, read (Unit)]
L3:
    read (Unit)                                                                            PREV:[jmp?(L3), jmp?(L5 [loop entry point])]
  2 jmp(L9 [skipFinallyToErrorBlock])                                                      NEXT:[mark({ 2 })]
L2 [onExceptionToFinallyBlock]:
L10 [start finally]:
  3 mark({ 2 })                                                                            PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v9>
L11 [finish finally]:
  2 jmp(error)                                                                             NEXT:[<ERROR>]
L9 [skipFinallyToErrorBlock]:
  3 mark({ 2 })                                                                            PREV:[jmp(L9 [skipFinallyToErrorBlock])]
    r(2) -> <v9>
L1:
  1 <END>                                                                                  NEXT:[<SINK>]
error:
    <ERROR>                                                                                PREV:[jmp(error)]
sink:
    <SINK>                                                                                 PREV:[<ERROR>, <END>]
=====================
== t11 ==
fun t11() {
  try {
    return 1
  }
  finally {
    return 2
  }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } finally { return 2 } })
    mark(try { return 1 } finally { return 2 })
    jmp?(L2 [onExceptionToFinallyBlock])               NEXT:[mark({ return 2 }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L3 [start finally]:
  4 mark({ return 2 })
    r(2) -> <v1>
    ret(*|<v1>) L1                                     NEXT:[<END>]
L4 [finish finally]:
- 3 ret(*|<v0>) L1                                     NEXT:[<END>]                                              PREV:[]
- 2 jmp(L5 [skipFinallyToErrorBlock])                  NEXT:[mark({ return 2 })]                                 PREV:[]
L2 [onExceptionToFinallyBlock]:
  4 mark({ return 2 })                                 PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(2) -> <v1>
    ret(*|<v1>) L1                                     NEXT:[<END>]
- 2 jmp(error)                                         NEXT:[<ERROR>]                                            PREV:[]
L5 [skipFinallyToErrorBlock]:
- 4 mark({ return 2 })                                 PREV:[]
-   r(2) -> <v1>                                       PREV:[]
-   ret(*|<v1>) L1                                     PREV:[]
L1:
  1 <END>                                              NEXT:[<SINK>]                                             PREV:[ret(*|<v1>) L1, ret(*|<v1>) L1]
error:
    <ERROR>                                            PREV:[]
sink:
    <SINK>                                             PREV:[<ERROR>, <END>]
=====================
== t12 ==
fun t12() : Int {
    try {
        return 1
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } finally { doSmth(3) } })
    mark(try { return 1 } finally { doSmth(3) })
    jmp?(L2 [onExceptionToFinallyBlock])                NEXT:[mark({ doSmth(3) }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L3 [start finally]:
  4 mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
L4 [finish finally]:
  3 ret(*|<v0>) L1                                      NEXT:[<END>]
- 2 jmp(L5 [skipFinallyToErrorBlock])                   NEXT:[mark({ doSmth(3) })]                                 PREV:[]
L2 [onExceptionToFinallyBlock]:
  4 mark({ doSmth(3) })                                 PREV:[jmp?(L2 [onExceptionToFinallyBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
  2 jmp(error)                                          NEXT:[<ERROR>]
L5 [skipFinallyToErrorBlock]:
- 4 mark({ doSmth(3) })                                 PREV:[]
-   r(3) -> <v1>                                        PREV:[]
-   mark(doSmth(3))                                     PREV:[]
-   call(doSmth, doSmth|<v1>) -> <v2>                   PREV:[]
L1:
  1 <END>                                               NEXT:[<SINK>]                                              PREV:[ret(*|<v0>) L1]
error:
    <ERROR>                                             PREV:[jmp(error)]
sink:
    <SINK>                                              PREV:[<ERROR>, <END>]
=====================
== t13 ==
fun t13() : Int {
    try {
        return 1
    }
    catch (e: UnsupportedOperationException) {
        doSmth(2)
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } finally { doSmth(3) } })
    mark(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } finally { doSmth(3) })
    jmp?(L2 [onException])                                                                                     NEXT:[v(e: UnsupportedOperationException), jmp?(L3 [onExceptionToFinallyBlock])]
    jmp?(L3 [onExceptionToFinallyBlock])                                                                       NEXT:[mark({ doSmth(3) }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L4 [start finally]:
  4 mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
L5 [finish finally]:
  3 ret(*|<v0>) L1                                                                                             NEXT:[<END>]
- 2 jmp(L6 [afterCatches])                                                                                     NEXT:[jmp(L7 [skipFinallyToErrorBlock])]                                                                          PREV:[]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                        PREV:[jmp?(L2 [onException])]
    magic(e: UnsupportedOperationException) -> <v3>
    w(e|<v3>)
  4 mark({ doSmth(2) })
    r(2) -> <v4>
    mark(doSmth(2))
    call(doSmth, doSmth|<v4>) -> <v5>
  3 jmp(L6 [afterCatches])
L6 [afterCatches]:
  2 jmp(L7 [skipFinallyToErrorBlock])                                                                          NEXT:[mark({ doSmth(3) })]
L3 [onExceptionToFinallyBlock]:
  4 mark({ doSmth(3) })                                                                                        PREV:[jmp?(L3 [onExceptionToFinallyBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
  2 jmp(error)                                                                                                 NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
  4 mark({ doSmth(3) })                                                                                        PREV:[jmp(L7 [skipFinallyToErrorBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
L1:
  1 <END>                                                                                                      NEXT:[<SINK>]                                                                                                     PREV:[ret(*|<v0>) L1, call(doSmth, doSmth|<v1>) -> <v2>]
error:
    <ERROR>                                                                                                    PREV:[jmp(error)]
sink:
    <SINK>                                                                                                     PREV:[<ERROR>, <END>]
=====================
== t14 ==
fun t14() : Int {
    try {
        return 1
    }
    catch (e: UnsupportedOperationException) {
        doSmth(2)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) } })
    mark(try { return 1 } catch (e: UnsupportedOperationException) { doSmth(2) })
    jmp?(L2 [onException])                                                               NEXT:[v(e: UnsupportedOperationException), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
    ret(*|<v0>) L1                                                                       NEXT:[<END>]
- 2 jmp(L3 [afterCatches])                                                               NEXT:[<END>]                                                                                PREV:[]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                  PREV:[jmp?(L2 [onException])]
    magic(e: UnsupportedOperationException) -> <v1>
    w(e|<v1>)
  4 mark({ doSmth(2) })
    r(2) -> <v2>
    mark(doSmth(2))
    call(doSmth, doSmth|<v2>) -> <v3>
  3 jmp(L3 [afterCatches])
L1:
L3 [afterCatches]:
  1 <END>                                                                                NEXT:[<SINK>]                                                                               PREV:[ret(*|<v0>) L1, jmp(L3 [afterCatches])]
error:
    <ERROR>                                                                              PREV:[]
sink:
    <SINK>                                                                               PREV:[<ERROR>, <END>]
=====================
== t15 ==
fun t15() : Int {
    try {
        return 1
    }
    catch (e: UnsupportedOperationException) {
        return 2
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { return 1 } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) } })
    mark(try { return 1 } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) })
    jmp?(L2 [onException])                                                                                    NEXT:[v(e: UnsupportedOperationException), jmp?(L3 [onExceptionToFinallyBlock])]
    jmp?(L3 [onExceptionToFinallyBlock])                                                                      NEXT:[mark({ doSmth(3) }), mark({ return 1 })]
  3 mark({ return 1 })
    r(1) -> <v0>
L4 [start finally]:
  4 mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
L5 [finish finally]:
  3 ret(*|<v0>) L1                                                                                            NEXT:[<END>]
- 2 jmp(L6 [afterCatches])                                                                                    NEXT:[jmp(L7 [skipFinallyToErrorBlock])]                                                                         PREV:[]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                       PREV:[jmp?(L2 [onException])]
    magic(e: UnsupportedOperationException) -> <v3>
    w(e|<v3>)
  4 mark({ return 2 })
    r(2) -> <v4>
    mark({ doSmth(3) })
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
    ret(*|<v4>) L1                                                                                            NEXT:[<END>]
- 3 jmp(L6 [afterCatches])                                                                                    PREV:[]
L6 [afterCatches]:
- 2 jmp(L7 [skipFinallyToErrorBlock])                                                                         NEXT:[mark({ doSmth(3) })]                                                                                       PREV:[]
L3 [onExceptionToFinallyBlock]:
  4 mark({ doSmth(3) })                                                                                       PREV:[jmp?(L3 [onExceptionToFinallyBlock])]
    r(3) -> <v1>
    mark(doSmth(3))
    call(doSmth, doSmth|<v1>) -> <v2>
  2 jmp(error)                                                                                                NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
- 4 mark({ doSmth(3) })                                                                                       PREV:[]
-   r(3) -> <v1>                                                                                              PREV:[]
-   mark(doSmth(3))                                                                                           PREV:[]
-   call(doSmth, doSmth|<v1>) -> <v2>                                                                         PREV:[]
L1:
  1 <END>                                                                                                     NEXT:[<SINK>]                                                                                                    PREV:[ret(*|<v0>) L1, ret(*|<v4>) L1]
error:
    <ERROR>                                                                                                   PREV:[jmp(error)]
sink:
    <SINK>                                                                                                    PREV:[<ERROR>, <END>]
=====================
== t16 ==
fun t16() : Int {
    try {
        doSmth(1)
    }
    catch (e: UnsupportedOperationException) {
        return 2
    }
    finally {
        doSmth(3)
    }
}
---------------------
L0:
  1 <START>
  2 mark({ try { doSmth(1) } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) } })
    mark(try { doSmth(1) } catch (e: UnsupportedOperationException) { return 2 } finally { doSmth(3) })
    jmp?(L2 [onException])                                                                                     NEXT:[v(e: UnsupportedOperationException), jmp?(L3 [onExceptionToFinallyBlock])]
    jmp?(L3 [onExceptionToFinallyBlock])                                                                       NEXT:[mark({ doSmth(3) }), mark({ doSmth(1) })]
  3 mark({ doSmth(1) })
    r(1) -> <v0>
    mark(doSmth(1))
    call(doSmth, doSmth|<v0>) -> <v1>
  2 jmp(L4 [afterCatches])                                                                                     NEXT:[jmp(L7 [skipFinallyToErrorBlock])]
L2 [onException]:
  3 v(e: UnsupportedOperationException)                                                                        PREV:[jmp?(L2 [onException])]
    magic(e: UnsupportedOperationException) -> <v2>
    w(e|<v2>)
  4 mark({ return 2 })
    r(2) -> <v3>
L5 [start finally]:
  5 mark({ doSmth(3) })
    r(3) -> <v4>
    mark(doSmth(3))
    call(doSmth, doSmth|<v4>) -> <v5>
L6 [finish finally]:
  4 ret(*|<v3>) L1                                                                                             NEXT:[<END>]
- 3 jmp(L4 [afterCatches])                                                                                     PREV:[]
L4 [afterCatches]:
  2 jmp(L7 [skipFinallyToErrorBlock])                                                                          NEXT:[mark({ doSmth(3) })]                                                                                        PREV:[jmp(L4 [afterCatches])]
L3 [onExceptionToFinallyBlock]:
  5 mark({ doSmth(3) })                                                                                        PREV:[jmp?(L3 [onExceptionToFinallyBlock])]
    r(3) -> <v4>
    mark(doSmth(3))
    call(doSmth, doSmth|<v4>) -> <v5>
  2 jmp(error)                                                                                                 NEXT:[<ERROR>]
L7 [skipFinallyToErrorBlock]:
  5 mark({ doSmth(3) })                                                                                        PREV:[jmp(L7 [skipFinallyToErrorBlock])]
    r(3) -> <v4>
    mark(doSmth(3))
    call(doSmth, doSmth|<v4>) -> <v5>
L1:
  1 <END>                                                                                                      NEXT:[<SINK>]                                                                                                     PREV:[ret(*|<v3>) L1, call(doSmth, doSmth|<v4>) -> <v5>]
error:
    <ERROR>                                                                                                    PREV:[jmp(error)]
sink:
    <SINK>                                                                                                     PREV:[<ERROR>, <END>]
=====================
== doSmth ==
fun doSmth(i: Int) {
}
---------------------
L0:
  1 <START>
    v(i: Int)
    magic(i: Int) -> <v0>
    w(i|<v0>)
  2 mark({ })
    read (Unit)
L1:
  1 <END>                    NEXT:[<SINK>]
error:
    <ERROR>                  PREV:[]
sink:
    <SINK>                   PREV:[<ERROR>, <END>]
=====================
