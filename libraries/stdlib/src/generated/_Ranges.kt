@file:kotlin.jvm.JvmMultifileClass
@file:kotlin.jvm.JvmName("RangesKt")

package kotlin

//
// NOTE THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//

import java.util.*

import java.util.Collections // TODO: it's temporary while we have java.util.Collections in js

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("downTo") kotlin.jvm.JvmVersion]
public fun Byte.`-downTo`(to: Byte): ByteProgression {
    return ByteProgression.fromClosedRange(this, to, -1)
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("downTo") kotlin.jvm.JvmVersion]
public fun Short.`-downTo`(to: Byte): ShortProgression {
    return ShortProgression.fromClosedRange(this, to.toShort(), -1)
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("downTo") kotlin.jvm.JvmVersion]
public fun Byte.`-downTo`(to: Short): ShortProgression {
    return ShortProgression.fromClosedRange(this.toShort(), to, -1)
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("downTo") kotlin.jvm.JvmVersion]
public fun Short.`-downTo`(to: Short): ShortProgression {
    return ShortProgression.fromClosedRange(this, to, -1)
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("until") kotlin.jvm.JvmVersion]
public fun Byte.`-until`(to: Byte): ByteRange {
    val to_  = (to - 1).toByte()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return ByteRange(this, to_)
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("until") kotlin.jvm.JvmVersion]
public fun Short.`-until`(to: Byte): ShortRange {
    return ShortRange(this, (to.toShort() - 1).toShort())
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("until") kotlin.jvm.JvmVersion]
public fun Byte.`-until`(to: Short): ShortRange {
    val to_  = (to - 1).toShort()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return ShortRange(this.toShort(), to_)
}

@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@[kotlin.jvm.JvmName("until") kotlin.jvm.JvmVersion]
public fun Short.`-until`(to: Short): ShortRange {
    val to_  = (to - 1).toShort()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return ShortRange(this, to_)
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("intRangeContains")
public operator fun Range<Int>.contains(item: Byte): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("intRangeContains")
public operator fun ClosedRange<Int>.contains(item: Byte): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("longRangeContains")
public operator fun Range<Long>.contains(item: Byte): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("longRangeContains")
public operator fun ClosedRange<Long>.contains(item: Byte): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun Range<Short>.contains(item: Byte): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun ClosedRange<Short>.contains(item: Byte): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun Range<Double>.contains(item: Byte): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun ClosedRange<Double>.contains(item: Byte): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun Range<Float>.contains(item: Byte): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun ClosedRange<Float>.contains(item: Byte): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("intRangeContains")
public operator fun Range<Int>.contains(item: Double): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("intRangeContains")
public operator fun ClosedRange<Int>.contains(item: Double): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("longRangeContains")
public operator fun Range<Long>.contains(item: Double): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("longRangeContains")
public operator fun ClosedRange<Long>.contains(item: Double): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun Range<Byte>.contains(item: Double): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun ClosedRange<Byte>.contains(item: Double): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun Range<Short>.contains(item: Double): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun ClosedRange<Short>.contains(item: Double): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun Range<Float>.contains(item: Double): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun ClosedRange<Float>.contains(item: Double): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("intRangeContains")
public operator fun Range<Int>.contains(item: Float): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("intRangeContains")
public operator fun ClosedRange<Int>.contains(item: Float): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("longRangeContains")
public operator fun Range<Long>.contains(item: Float): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("longRangeContains")
public operator fun ClosedRange<Long>.contains(item: Float): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun Range<Byte>.contains(item: Float): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun ClosedRange<Byte>.contains(item: Float): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun Range<Short>.contains(item: Float): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun ClosedRange<Short>.contains(item: Float): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun Range<Double>.contains(item: Float): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun ClosedRange<Double>.contains(item: Float): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("longRangeContains")
public operator fun Range<Long>.contains(item: Int): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("longRangeContains")
public operator fun ClosedRange<Long>.contains(item: Int): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun Range<Byte>.contains(item: Int): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun ClosedRange<Byte>.contains(item: Int): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun Range<Short>.contains(item: Int): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun ClosedRange<Short>.contains(item: Int): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun Range<Double>.contains(item: Int): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun ClosedRange<Double>.contains(item: Int): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun Range<Float>.contains(item: Int): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun ClosedRange<Float>.contains(item: Int): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("intRangeContains")
public operator fun Range<Int>.contains(item: Long): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("intRangeContains")
public operator fun ClosedRange<Int>.contains(item: Long): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun Range<Byte>.contains(item: Long): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun ClosedRange<Byte>.contains(item: Long): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun Range<Short>.contains(item: Long): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("shortRangeContains")
public operator fun ClosedRange<Short>.contains(item: Long): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun Range<Double>.contains(item: Long): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun ClosedRange<Double>.contains(item: Long): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun Range<Float>.contains(item: Long): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun ClosedRange<Float>.contains(item: Long): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("intRangeContains")
public operator fun Range<Int>.contains(item: Short): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("intRangeContains")
public operator fun ClosedRange<Int>.contains(item: Short): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("longRangeContains")
public operator fun Range<Long>.contains(item: Short): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("longRangeContains")
public operator fun ClosedRange<Long>.contains(item: Short): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun Range<Byte>.contains(item: Short): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("byteRangeContains")
public operator fun ClosedRange<Byte>.contains(item: Short): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun Range<Double>.contains(item: Short): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("doubleRangeContains")
public operator fun ClosedRange<Double>.contains(item: Short): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun Range<Float>.contains(item: Short): Boolean {
    return start <= item && item <= end
}

/**
 * Checks if the specified [item] belongs to this range.
 */
@kotlin.jvm.JvmName("floatRangeContains")
public operator fun ClosedRange<Float>.contains(item: Short): Boolean {
    return start <= item && item <= endInclusive
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Int.downTo(to: Byte): IntProgression {
    return IntProgression.fromClosedRange(this, to.toInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Long.downTo(to: Byte): LongProgression {
    return LongProgression.fromClosedRange(this, to.toLong(), -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Byte.downTo(to: Byte): IntProgression {
    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Short.downTo(to: Byte): IntProgression {
    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Char.downTo(to: Char): CharProgression {
    return CharProgression.fromClosedRange(this, to, -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Int.downTo(to: Int): IntProgression {
    return IntProgression.fromClosedRange(this, to, -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Long.downTo(to: Int): LongProgression {
    return LongProgression.fromClosedRange(this, to.toLong(), -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Byte.downTo(to: Int): IntProgression {
    return IntProgression.fromClosedRange(this.toInt(), to, -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Short.downTo(to: Int): IntProgression {
    return IntProgression.fromClosedRange(this.toInt(), to, -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Int.downTo(to: Long): LongProgression {
    return LongProgression.fromClosedRange(this.toLong(), to, -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Long.downTo(to: Long): LongProgression {
    return LongProgression.fromClosedRange(this, to, -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Byte.downTo(to: Long): LongProgression {
    return LongProgression.fromClosedRange(this.toLong(), to, -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Short.downTo(to: Long): LongProgression {
    return LongProgression.fromClosedRange(this.toLong(), to, -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Int.downTo(to: Short): IntProgression {
    return IntProgression.fromClosedRange(this, to.toInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Long.downTo(to: Short): LongProgression {
    return LongProgression.fromClosedRange(this, to.toLong(), -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Byte.downTo(to: Short): IntProgression {
    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the increment -1.
 * The [to] value has to be less than this value.
 */
public infix fun Short.downTo(to: Short): IntProgression {
    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
public fun CharProgression.reversed(): CharProgression {
    return CharProgression.fromClosedRange(last, first, -increment)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
public fun IntProgression.reversed(): IntProgression {
    return IntProgression.fromClosedRange(last, first, -increment)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
public fun LongProgression.reversed(): LongProgression {
    return LongProgression.fromClosedRange(last, first, -increment)
}

/**
 * Returns a progression that goes over this range in reverse direction.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public fun CharRange.reversed(): CharProgression {
    return CharProgression.fromClosedRange(last, first, -1)
}

/**
 * Returns a progression that goes over this range in reverse direction.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public fun IntRange.reversed(): IntProgression {
    return IntProgression.fromClosedRange(last, first, -1)
}

/**
 * Returns a progression that goes over this range in reverse direction.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public fun LongRange.reversed(): LongProgression {
    return LongProgression.fromClosedRange(last, first, -1L)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
@Deprecated("This range implementation has unclear semantics and will be removed soon.")
@Suppress("DEPRECATION_ERROR")
public fun ByteProgression.reversed(): ByteProgression {
    return ByteProgression.fromClosedRange(last, first, -increment)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
@Deprecated("This range implementation has unclear semantics and will be removed soon.")
@Suppress("DEPRECATION_ERROR")
public fun ShortProgression.reversed(): ShortProgression {
    return ShortProgression.fromClosedRange(last, first, -increment)
}

/**
 * Returns a progression that goes over this range in reverse direction.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@Suppress("DEPRECATION_ERROR")
public fun ByteRange.reversed(): ByteProgression {
    return ByteProgression.fromClosedRange(last, first, -1)
}

/**
 * Returns a progression that goes over this range in reverse direction.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@Suppress("DEPRECATION_ERROR")
public fun ShortRange.reversed(): ShortProgression {
    return ShortProgression.fromClosedRange(last, first, -1)
}

/**
 * Returns a progression that goes over the same range with the given step.
 */
public infix fun CharProgression.step(step: Int): CharProgression {
    checkStepIsPositive(step > 0, step)
    return CharProgression.fromClosedRange(first, last, if (increment > 0) step else -step)
}

/**
 * Returns a progression that goes over the same range with the given step.
 */
public infix fun IntProgression.step(step: Int): IntProgression {
    checkStepIsPositive(step > 0, step)
    return IntProgression.fromClosedRange(first, last, if (increment > 0) step else -step)
}

/**
 * Returns a progression that goes over the same range with the given step.
 */
public infix fun LongProgression.step(step: Long): LongProgression {
    checkStepIsPositive(step > 0, step)
    return LongProgression.fromClosedRange(first, last, if (increment > 0) step else -step)
}

/**
 * Returns a progression that goes over this range with given step.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public infix fun CharRange.step(step: Int): CharProgression {
    checkStepIsPositive(step > 0, step)
    return CharProgression.fromClosedRange(first, last, step)
}

/**
 * Returns a progression that goes over this range with given step.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public infix fun IntRange.step(step: Int): IntProgression {
    checkStepIsPositive(step > 0, step)
    return IntProgression.fromClosedRange(first, last, step)
}

/**
 * Returns a progression that goes over this range with given step.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public infix fun LongRange.step(step: Long): LongProgression {
    checkStepIsPositive(step > 0, step)
    return LongProgression.fromClosedRange(first, last, step)
}

/**
 * Returns a progression that goes over the same range with the given step.
 */
@Deprecated("This range implementation has unclear semantics and will be removed soon.")
@Suppress("DEPRECATION_ERROR")
public infix fun ByteProgression.step(step: Int): ByteProgression {
    checkStepIsPositive(step > 0, step)
    return ByteProgression.fromClosedRange(first, last, if (increment > 0) step else -step)
}

/**
 * Returns a progression that goes over the same range with the given step.
 */
@Deprecated("This range implementation has unclear semantics and will be removed soon.")
@Suppress("DEPRECATION_ERROR")
public infix fun ShortProgression.step(step: Int): ShortProgression {
    checkStepIsPositive(step > 0, step)
    return ShortProgression.fromClosedRange(first, last, if (increment > 0) step else -step)
}

/**
 * Returns a progression that goes over this range with given step.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@Suppress("DEPRECATION_ERROR")
public infix fun ByteRange.step(step: Int): ByteProgression {
    checkStepIsPositive(step > 0, step)
    return ByteProgression.fromClosedRange(first, last, step)
}

/**
 * Returns a progression that goes over this range with given step.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
@Suppress("DEPRECATION_ERROR")
public infix fun ShortRange.step(step: Int): ShortProgression {
    checkStepIsPositive(step > 0, step)
    return ShortProgression.fromClosedRange(first, last, step)
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Int.until(to: Byte): IntRange {
    return this .. (to.toInt() - 1).toInt()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Long.until(to: Byte): LongRange {
    return this .. (to.toLong() - 1).toLong()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Byte.until(to: Byte): IntRange {
    return this.toInt() .. (to.toInt() - 1).toInt()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Short.until(to: Byte): IntRange {
    return this.toInt() .. (to.toInt() - 1).toInt()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Char.MIN_VALUE].
 */
public infix fun Char.until(to: Char): CharRange {
    val to_  = (to.toInt() - 1).toChar()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Int.MIN_VALUE].
 */
public infix fun Int.until(to: Int): IntRange {
    val to_  = (to.toLong() - 1).toInt()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Long.until(to: Int): LongRange {
    return this .. (to.toLong() - 1).toLong()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Int.MIN_VALUE].
 */
public infix fun Byte.until(to: Int): IntRange {
    val to_  = (to.toLong() - 1).toInt()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this.toInt() .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Int.MIN_VALUE].
 */
public infix fun Short.until(to: Int): IntRange {
    val to_  = (to.toLong() - 1).toInt()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this.toInt() .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Long.MIN_VALUE].
 */
public infix fun Int.until(to: Long): LongRange {
    val to_  = (to - 1).toLong()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this.toLong() .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Long.MIN_VALUE].
 */
public infix fun Long.until(to: Long): LongRange {
    val to_  = (to - 1).toLong()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Long.MIN_VALUE].
 */
public infix fun Byte.until(to: Long): LongRange {
    val to_  = (to - 1).toLong()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this.toLong() .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 * The [to] value must be greater than [Long.MIN_VALUE].
 */
public infix fun Short.until(to: Long): LongRange {
    val to_  = (to - 1).toLong()
    if (to_ > to) throw IllegalArgumentException("The to argument value '$to' was too small.")
    return this.toLong() .. to_
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Int.until(to: Short): IntRange {
    return this .. (to.toInt() - 1).toInt()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Long.until(to: Short): LongRange {
    return this .. (to.toLong() - 1).toLong()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Byte.until(to: Short): IntRange {
    return this.toInt() .. (to.toInt() - 1).toInt()
}

/**
 * Returns a range from this value up to but excluding the specified [to] value.
 */
public infix fun Short.until(to: Short): IntRange {
    return this.toInt() .. (to.toInt() - 1).toInt()
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun <T: Comparable<T>> T.coerceAtLeast(minimumValue: T): T {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun Byte.coerceAtLeast(minimumValue: Byte): Byte {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun Double.coerceAtLeast(minimumValue: Double): Double {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun Float.coerceAtLeast(minimumValue: Float): Float {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun Int.coerceAtLeast(minimumValue: Int): Int {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun Long.coerceAtLeast(minimumValue: Long): Long {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not less than the specified [minimumValue].
 * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.
 */
public fun Short.coerceAtLeast(minimumValue: Short): Short {
    return if (this < minimumValue) minimumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun <T: Comparable<T>> T.coerceAtMost(maximumValue: T): T {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun Byte.coerceAtMost(maximumValue: Byte): Byte {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun Double.coerceAtMost(maximumValue: Double): Double {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun Float.coerceAtMost(maximumValue: Float): Float {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun Int.coerceAtMost(maximumValue: Int): Int {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun Long.coerceAtMost(maximumValue: Long): Long {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value is not greater than the specified [maximumValue].
 * @return this value if it's greater than or equal to the [maximumValue] or the [maximumValue] otherwise.
 */
public fun Short.coerceAtMost(maximumValue: Short): Short {
    return if (this > maximumValue) maximumValue else this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun <T: Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun Byte.coerceIn(minimumValue: Byte?, maximumValue: Byte?): Byte {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun Double.coerceIn(minimumValue: Double?, maximumValue: Double?): Double {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun Float.coerceIn(minimumValue: Float?, maximumValue: Float?): Float {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun Int.coerceIn(minimumValue: Int?, maximumValue: Int?): Int {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun Long.coerceIn(minimumValue: Long?, maximumValue: Long?): Long {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].
 * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].
 */
public fun Short.coerceIn(minimumValue: Short?, maximumValue: Short?): Short {
    if (minimumValue !== null && maximumValue !== null) {
        if (minimumValue > maximumValue) throw IllegalArgumentException("Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.")
        if (this < minimumValue) return minimumValue
        if (this > maximumValue) return maximumValue
    }
    else {
        if (minimumValue !== null && this < minimumValue) return minimumValue
        if (maximumValue !== null && this > maximumValue) return maximumValue
    }
    return this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
public fun <T: Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.endInclusive) range.endInclusive else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
public fun Int.coerceIn(range: ClosedRange<Int>): Int {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.endInclusive) range.endInclusive else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
public fun Long.coerceIn(range: ClosedRange<Long>): Long {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.endInclusive) range.endInclusive else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public fun <T: Comparable<T>> T.coerceIn(range: Range<T>): T {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
public fun Byte.coerceIn(range: Range<Byte>): Byte {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
public fun Int.coerceIn(range: Range<Int>): Int {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
public fun Long.coerceIn(range: Range<Long>): Long {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Range<T> is deprecated. Use ClosedRange<T> instead.")
public fun Short.coerceIn(range: Range<Short>): Short {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public fun Double.coerceIn(range: Range<Double>): Double {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

/**
 * Ensures that this value lies in the specified [range].
 * @return this value if it's in the [range], or range.start if this value is less than range.start, or range.end if this value is greater than range.end.
 */
@Deprecated("Provided for binary compatibility", level = DeprecationLevel.HIDDEN)
public fun Float.coerceIn(range: Range<Float>): Float {
    if (range.isEmpty()) throw IllegalArgumentException("Cannot coerce value to an empty range: $range.")
    return if (this < range.start) range.start else if (this > range.end) range.end else this
}

